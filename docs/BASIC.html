<html>
<div style="position: relative; left: 1150px; top: 0px;">
<img src="data/logo.png" align="center">
</div>
<style>
body {
  background-image: url(data/background.jpg);
  background-size: cover;
}
</style>
<font color=#FFFFFF face="Verdana"> 
<h1>REX Virtual Machine Documentation</h1>
<h1>THIS DOCUMENT IS BEING WORKED ON!</h1>
<h2>BASIC</h2>
An implementation of TinyBASIC is the only HLL language which is ported to R3X VM.
<h3>Let's begin with a "Hello, World!"</h3>
First compile the compiler using the GNU Compiler Toolchain (YOU WILL NEED IT WHILE RUNNING TOO!). If your system has the required tools, then it's simply a <br>
<pre>
	export PREFIX="&lt;path where you want the executable to be stored&gt;"
	./buildutils.sh
</pre>
Then you can export it in your PATH like this:<br>
<pre>
	export PATH=$PATH:$PREFIX
</pre>
NOTE: TinyBASIC compiler for R3X uses GCC as it's preprocessor, you will need the gcc toolchain in order to compile R3X programs!<br>
Let's begin with some code? Shall we? :)
<pre>
function main, 0
	/* This is a comment */
	/* Print Hello, world to screen */
	print "Hello, World!"
	/* Exit */
	end
endf
</pre>
Using a text editor, save this file as "hello.bas", and run t++, with the following:<br>
t++ -s hello.bas -o hello.asm<br>
Now it should generate an assembler file, however if you use FASM to compi
rxvm -exe ./hello.exe
</pre>
You should see the words "Hello, World!" on the output screen. If you press a key, then the program will exit.<br>
<h3>Variable Assigment</h3>
TinyBASIC++ is a typeless language, meaning one variable is not limited to one type.<br>
All variables are assigned with the "let" keyword. The first "let" keyword is supposed to initialize the variable.
<pre>
let int = 27+3
let str = "Hello, World!"
...
</pre>
Note that there is no such thing as a global variable, and when you refer to the variable, you're referring to something current scope.<br>
<h3>Memory Allocation</h3>
Memory allocation is supported through the "alloc" variable, use it like this:
<pre>
alloc buffer = size
</pre>
"buffer" could be anything you wish, now buffer = pointer to a region of memory mapped as data.<br>
<h3>Memory Access Operators</h3>
There are "memory access" operators which can help you access certain region in memory, these are:
<pre>
int32_ptr(addr) - 32-bit memory access
int16_ptr(addr) - 16-bit memory access
int8_ptr(addr) - 8-bit memory access
</pre>
To set a location in memory, you can make use of the "let" keyword:
<pre>
	// Set a 32-bit value at memory location 0x1000 
	let int32_ptr(0x1000) = 0xFFFFFFFF
	// Set a 16-bit value at memory location pointed by "buffer+5"
	let x = 65535
	let int16_ptr(buffer+5) = x
	...
</pre>
<h3>Program/Control Flow and looping</h3>
<h3>goto</h3>
The "goto" keyword monitors function-specific program flow through a system of labels.<br>
A label can be declared with a semicolon in front of it:<br>
<pre>
...
:label
...
</pre>
You can then jump to this label using "goto":<br>
<pre>
...
goto label
...
</pre>
You can also "gosub", if you want recursion, note that you would need to return as well. [You may rather use functions for this!]
<pre>
:label
	...
	do stuff
	...
	// This will be explained in detail under "functions"
	return 0 
...
gosub label
...
code after this will run as expected
</pre>
NOTE: Labels cannot be used in expressions!
Control flow in TinyBASIC++ is achieved through 2 keywords: "IF" and "WHILE"<br>
The "if" keyword compares two expressions and then performs a statment, (usually a goto to a label)<br>
<pre>
...
	if a = 5 goto yes
	if a != 5 goto yes
	if a &lt; 5 goto yes
	if a &gt; 5 goto yes
	if a &lt;= 5 goto yes
	if a &gt;= 5 goto yes
	// Labels are scope-specific
:yes
...
</pre>
The "while" keyword loops through the code between it and another keyword "endw" provided the condition is true [like if] (end while).<br>
<pre>
...
	while a &lt; 5
		...
		let a = a + 1
		...
	endw 
</pre>
<h3>Functions</h3>
Functions are certain pieces of code which are organized together, and expect input and give output. In the "Hello, World" example we saw, <br>
a "function main, 0" -- This is the "main" function and is called by libR3X after it's initialization.
Here's a simple example on how to use functions:
<pre>
function addtwonumbers, 2
	let a = $1+$2
	return a
endf
</pre>
The above code declares a function with 2 arguments as "add2numbers". It then uses a local variable called a to add it's first and second argument (referenced<br>
by $1, and $2 respectively), to store the result of the addition. It then returns a.<br>
This can now be called like this, from another function:<br>
<pre>
	...
	let result = @add2numbers(57, 90)
	...
</pre>
Or you can simply call it like this, and trash the result:<br>
<pre>
	@add2numbers(57, 90)
</pre>
You can also pass expressions, like this:<br>
<pre>
	@add2numbers(myvar1*20+60, myvar2-15)
</pre>
You must always return, or not returning from a function causes undefined behaviour, for functions that don't<br>
intend to return anything use:<br>
<pre>
	...
	return 0
</pre>
<h3>Internal functions</h3>
TinyBASIC++ provides 4 internal functions for a program to use.<br>
<h4>print</h4>
	The "print" function outputs a string / integer to stdout. The usage is shown below:<br>
<pre>
	...
	// Print a literal string
	print "hello"
	// Print a string stored in a pointer
	print $variable
	// Print an integer
	print my_int
	// Print a string + integer
	print "hello: "; my_int1, my_int2+1, my_int3*3 ...
</pre>
<h4>input</h4>
	The "input" function inputs a single character from stdin into a variable. The usage is shown below:<br>
<pre>
	...
	input my_var
	# might store it or use it?
	if my_var == 'y' goto yes
	...
	let [buffer] = my_var
</pre>
<h4>alloc</h4>
	The "alloc" function allocates a region of memory, by size, and then puts the pointer into a variable<br>
	<pre>
	#! Allocate 256 bytes and assign pointer to x
	alloc x = 256
	</pre>
<h4>end</h4>
	The "end" function simply quits the program.<br>
<h3>Inline assembler</h3>
Inline assembly can be achieved through the "asm" keyword, like this:<br>
<pre>
	...
	asm "loadrr R1, R5"
	asm "pushr R1"
	asm "popr R5"
	...
</pre>
Of course, you're !not! supposed to mess up the stack, while doing inline asm, ALWAYS restore it before resuming back to<br>
tbc code.<br>
If you want to refer to a variable's address, you can do: 
<pre>
function myfunc, 0
	...
	let var = 5
	// Address of variable = v[function name].[variable name]
	asm "loadr R0, vmyfunc.var"
</pre>
Labels can be used in a similar way:<br>
<pre>
function myfunc, 0
	...
:label
	...
	// Address of label = l[function name].[variable name]
	asm "loadr R0, lmyfunc.label"
</pre>
<h3>Floating Point Numbers</h3>
Floating Point Numbers are represented like: 30.3256 (note the dot).<br>
If you want an absolute number, you must do something like: 30.0<br>
You are allowed to use floating point numbers, however you must use certain operators to do operations on floats.<br>
<pre>
add_f(expression, expression) : add two floating point numbers, given out by expression
mul_f(expression, expression) : multiply two floating point numbers, given out by expression
div_f(expression, expression) : divide two floating point numbers, given out by expression
mod_f(expression, expression) : do a modulo operation on two floating point numbers, given out by expression
</pre>
<h4>Adding floating point integers and conventional</h4>
Adding floats and integers together requires another operator: conv_i/conv_f<br>
Basically, conv_i rounds off a float to it's nearest integers and then converts it to a normal integer.<br>
conv_f on the other hand converts an integer to floating point representation.<br>
See float.bas for example usage.<br>
<h3>Operators</h3>
These are the following operators present in the language:<br>
<pre>
Highest precedence:
&gt;&gt; - Right shift 
&lt;&lt; - Left shift
& - Bitwise AND
| - Bitwise OR
^ - Bitwise XOR
1~ - Bitwise NOT (Neg)
1! - Logical NOT (Not)
Higher precedence:
* - Multiply
/ - Divide
% - Modulo
Low precedence:
+ - Plus
- - minus
</pre>
<h3>Preprocessor</h3>
t++ calls GCC first to do the preprocessing (using options -E and -P), which means you can use all C preprocessor features!<br>
Including another file is done like: <br>
<pre>
	#include "somefile.h"
</pre>
Definitions can be done like: <br>
<pre>
	#define MYVAR 1
	...
	/** And then can be used like **/
	let x = MYVAR
</pre>
You can also define expressions: <br>
<pre>
	#define ADD_1(x) (x+1)
	...
	let q = ADD_1(q)
</pre>


